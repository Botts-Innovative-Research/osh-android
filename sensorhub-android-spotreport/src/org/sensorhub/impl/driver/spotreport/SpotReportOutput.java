/***************************** BEGIN LICENSE BLOCK ***************************

 The contents of this file are subject to the Mozilla Public License, v. 2.0.
 If a copy of the MPL was not distributed with this file, You can obtain one
 at http://mozilla.org/MPL/2.0/.

 Software distributed under the License is distributed on an "AS IS" basis,
 WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 for the specific language governing rights and limitations under the License.

 Copyright (C) 2019 Botts Innovative Research, Inc. All Rights Reserved.
 ******************************* END LICENSE BLOCK ***************************/

package org.sensorhub.impl.driver.spotreport;

import java.io.ByteArrayOutputStream;
import java.util.List;

import net.opengis.swe.v20.Boolean;
import net.opengis.swe.v20.Count;
import net.opengis.swe.v20.DataBlock;
import net.opengis.swe.v20.DataComponent;
import net.opengis.swe.v20.DataEncoding;
import net.opengis.swe.v20.DataStream;
import net.opengis.swe.v20.Text;
import net.opengis.swe.v20.Time;
import net.opengis.swe.v20.Vector;

import org.sensorhub.api.sensor.SensorDataEvent;
import org.sensorhub.api.sensor.SensorException;
import org.sensorhub.impl.sensor.AbstractSensorOutput;
import org.sensorhub.impl.sensor.videocam.VideoCamHelper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.vast.data.AbstractDataBlock;
import org.vast.data.DataBlockList;
import org.vast.data.DataBlockMixed;
import org.vast.swe.SWEHelper;
import org.vast.swe.helper.GeoPosHelper;

import android.Manifest;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.location.Location;
import android.location.LocationManager;
import android.net.Uri;
import android.os.ResultReceiver;
import android.provider.MediaStore;

/**
 * <p>
 * Implementation of data interface for Spot Reports
 * </p>
 *
 * @author Nicolas Garay <nicolasgaray@icloud.com>
 * @since Nov 9, 2019
 */
public class SpotReportOutput extends AbstractSensorOutput<SpotReportDriver> {

    // keep logger name short because in LogCat it's max 23 chars
    static final Logger log = LoggerFactory.getLogger(SpotReportOutput.class.getSimpleName());

    // Data Associated with Broadcast Receivers and Intents
    private static final String ACTION_SUBMIT_REPORT = "org.sensorhub.android.intent.SPOT_REPORT";
    private static final int SUBMIT_REPORT_FAILURE = 0;
    private static final int SUBMIT_REPORT_SUCCESS = 1;
    private static final String DATA_LOC = "location";
    private static final String DATA_REPORT_NAME = "name";
    private static final String DATA_REPORT_DESCRIPTION = "description";
    private static final String DATA_REPORT_CATEGORY = "item";
    private static final String DATA_REPORT_IMAGE = "image";
    private SpotReportReceiver broadcastReceiver = new SpotReportReceiver();

    // SWE DataBlock elements
    private static final String DATA_RECORD_TIME_LABEL = "time";
    private static final String DATA_RECORD_LOC_LABEL = "location";
    private static final String DATA_RECORD_REPORT_NAME_LABEL = "name";
    private static final String DATA_RECORD_REPORT_DESCRIPTION_LABEL = "description";
    private static final String DATA_RECORD_REPORTING_CATEGORY_LABEL = "category";
    private static final String DATA_RECORD_REPORTING_CONTAINS_IMAGE_LABEL = "has-image";
    private static final String DATA_RECORD_REPORTING_IMAGE_LABEL = "image";

    private static final String DATA_RECORD_NAME = "Spot Report";
    private static final String DATA_RECORD_DESCRIPTION =
            "A report generated by visual observance and classification which is accompanied by a" +
                    " location, description, and optionally an image";
    private static final String DATA_RECORD_DEFINITION =
            SWEHelper.getPropertyUri("SpotReport");
    private int imgHeight;
    private int imgWidth;
    private DataComponent spotReport;
    private DataEncoding dataEncoding;

    private Context context;
    private String name;

    private ByteArrayOutputStream imageBuffer = new ByteArrayOutputStream();

    protected SpotReportOutput(SpotReportDriver parentModule) {

        super(parentModule);
        this.name = "spot_report_data";

        this.imgWidth = parentModule.getConfiguration().imgWidth;
        this.imgHeight = parentModule.getConfiguration().imgHeight;
    }

    @Override
    public String getName() {

        return name;
    }

    protected void init() throws SensorException {

        SWEHelper sweHelper = new SWEHelper();
        spotReport = sweHelper.newDataRecord(7);
        spotReport.setDescription(DATA_RECORD_DESCRIPTION);
        spotReport.setDefinition(DATA_RECORD_DEFINITION);
        spotReport.setName(DATA_RECORD_NAME);

        // Add the time stamp component of the data record
        Time time = sweHelper.newTimeStampIsoUTC();
        spotReport.addComponent(DATA_RECORD_TIME_LABEL, time);

        // Add the location component of the data record
        GeoPosHelper geoPosHelper = new GeoPosHelper();
        Vector vec = geoPosHelper.newLocationVectorLLA(null);
        vec.setLocalFrame(parentSensor.localFrameURI);
        spotReport.addComponent(DATA_RECORD_LOC_LABEL, vec);

        // Add the report name component of the data record
        Text name = sweHelper.newText();
        spotReport.addComponent(DATA_RECORD_REPORT_NAME_LABEL, name);

        // Add the report description component of the data record
        Text description = sweHelper.newText();
        spotReport.addComponent(DATA_RECORD_REPORT_DESCRIPTION_LABEL, description);

        // Add the reporting item component of the data record
        Text category = sweHelper.newText();
        spotReport.addComponent(DATA_RECORD_REPORTING_CATEGORY_LABEL, category);

        // Add image data block
        Boolean containsImage = sweHelper.newBoolean();
        spotReport.addComponent(DATA_RECORD_REPORTING_CONTAINS_IMAGE_LABEL, containsImage);

        VideoCamHelper videoCamHelper = new VideoCamHelper();
        DataStream videoStream = videoCamHelper.newVideoOutputMJPEG(getName(), this.imgWidth, this.imgHeight);
        videoStream.setDefinition(SWEHelper.getPropertyUri("Image"));
        Count count = sweHelper.newCount();
        count.setValue(1);
        videoStream.setElementCount(count);
        spotReport.addComponent(DATA_RECORD_REPORTING_IMAGE_LABEL, videoStream);

        // Output encoding
        dataEncoding = sweHelper.newBinaryEncoding();
    }

    private boolean submitReport(String category, String locationSource, String name, String description, byte[] image) {

        Location location;

        location = getLocation(locationSource);

        double sampleTime = location.getTime() / 1000.0;

        // build and populate datablock
        DataBlock dataBlock = spotReport.createDataBlock();
        dataBlock.setDoubleValue(0, sampleTime);
        AbstractDataBlock locationData = ((DataBlockMixed)dataBlock).getUnderlyingObject()[1];
        locationData.setDoubleValue(0, location.getLatitude());
        locationData.setDoubleValue(1, location.getLongitude());
        locationData.setDoubleValue(2, location.getAltitude());
        AbstractDataBlock nameData = ((DataBlockMixed)dataBlock).getUnderlyingObject()[2];
        nameData.setStringValue(name);
        AbstractDataBlock descriptionData = ((DataBlockMixed)dataBlock).getUnderlyingObject()[3];
        descriptionData.setStringValue(description);
        AbstractDataBlock categoryData = ((DataBlockMixed)dataBlock).getUnderlyingObject()[4];
        categoryData.setStringValue(category);
        boolean hasImage = true;
        if(image.length == 0) {
            hasImage = false;
        }
        dataBlock.setBooleanValue(5, hasImage);
        AbstractDataBlock frameData = ((DataBlockMixed)dataBlock).getUnderlyingObject()[6];
        ((DataBlockList)frameData).get(0).setDoubleValue(0, sampleTime);
        ((DataBlockMixed)((DataBlockList)frameData).get(0)).getUnderlyingObject()[1].setUnderlyingObject(image);

        // update latest record and send event
        latestRecord = dataBlock;
        latestRecordTime = System.currentTimeMillis();
        eventHandler.publishEvent(new SensorDataEvent(latestRecordTime, this, dataBlock));

        return true;
    }

    public void start(Context context) {

        this.context = context;
        context.registerReceiver(broadcastReceiver, new IntentFilter(ACTION_SUBMIT_REPORT));
    }
    
    @Override
    public void stop() {

        context.unregisterReceiver(broadcastReceiver);
    }

    @Override
    public double getAverageSamplingPeriod() {

        return 1;
    }

    @Override
    public DataComponent getRecordDescription() {

        return spotReport;
    }

    @Override
    public DataEncoding getRecommendedEncoding() {

        return dataEncoding;
    }
    
    @Override
    public DataBlock getLatestRecord() {

        return latestRecord;
    }
    
    @Override
    public long getLatestRecordTime() {

        return latestRecordTime;
    }

    private Location getLocation(String locationSource) {

        Location location = null;

        SpotReportConfig config = getParentModule().getConfiguration();

        // Attempt to get location based given location source
        if (config.androidContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION)) {

            // Retrieve the location manager
            LocationManager locationManager = (LocationManager) config.androidContext.getSystemService(Context.LOCATION_SERVICE);

            // Get a list of all location providers
            List<String> locProviders = locationManager.getAllProviders();

            // Scan through the list until a provider is matched
            for (String providerName : locProviders) {

                if (providerName.equalsIgnoreCase(locationSource)) {

                    log.debug("Detected location provider " + providerName);

                    if (context.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED ||
                            context.checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED) {

                        location = locationManager.getLastKnownLocation(providerName);

                        log.debug("Location " + location.toString());
                    }
                }
            }
        }

        return location;
    }

    private class SpotReportReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {

            if(intent.getAction().equals(ACTION_SUBMIT_REPORT)) {

                String category = intent.getStringExtra(DATA_REPORT_CATEGORY);
                String locationSource = intent.getStringExtra(DATA_LOC);
                String name = intent.getStringExtra(DATA_REPORT_NAME);
                String description = intent.getStringExtra(DATA_REPORT_DESCRIPTION);
                Uri imageUri = Uri.parse(intent.getStringExtra(DATA_REPORT_IMAGE));
                ResultReceiver resultReceiver = intent.getParcelableExtra(Intent.EXTRA_RESULT_RECEIVER);

                imageBuffer.reset();
                try {

                    Bitmap imageBitmap = MediaStore.Images.Media.getBitmap(context.getContentResolver(), imageUri);
                    imageBitmap.compress(Bitmap.CompressFormat.JPEG, 90, imageBuffer);

                    boolean success = submitReport(category, locationSource, name, description, imageBuffer.toByteArray());

                    if (success) {

                        resultReceiver.send(SUBMIT_REPORT_SUCCESS, null);
                    }
                    else {

                        resultReceiver.send(SUBMIT_REPORT_FAILURE, null);
                    }

                } catch(Exception e) {

                    resultReceiver.send(SUBMIT_REPORT_FAILURE, null);
                }
            }
        }
    }
}
