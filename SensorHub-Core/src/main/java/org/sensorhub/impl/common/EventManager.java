/***************************** BEGIN LICENSE BLOCK ***************************

 The contents of this file are copyright (C) 2010, Sensia Software LLC
 All Rights Reserved.

 Contributor(s): 
    Alexandre Robin <alex.robin@sensiasoftware.com>
 
******************************* END LICENSE BLOCK ***************************/

package org.sensorhub.impl.common;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.sensorhub.api.common.Event;
import org.sensorhub.api.common.IEventListener;


/**
 * <p><b>Title:</b>
 * EventManager
 * </p>
 *
 * <p><b>Description:</b><br/>
 * Class handling all event dispatching in SensorHub
 * </p>
 *
 * <p>Copyright (c) 2010</p>
 * @author Alexandre Robin
 * @date Aug 30, 2013
 */
public class EventManager
{
    private static EventManager singletonInstance;
    
    private Thread dispatchThread;
    private BlockingQueue<Event> eventQueue;
    private Map<Object, List<IEventListener>> listeners;
    private boolean started;
    private boolean paused;
    
    
    public static EventManager getInstance()
    {
        if (singletonInstance == null)
            singletonInstance = new EventManager();
        
        return singletonInstance;
    }
    
    
    private EventManager()
    {
        this.eventQueue = new LinkedBlockingQueue<Event>();
        this.listeners = new HashMap<Object, List<IEventListener>>();
        
        dispatchThread = new Thread() {            
            public void run()
            {                
                while (started)
                {
                    synchronized (this)
                    {
                        Event e = eventQueue.poll();
                        for (IEventListener l : listeners.get(e.getSource()))
                            l.handleEvent(e);
                        
                        try
                        {
                            while (paused)
                                this.wait();
                        }
                        catch (InterruptedException e1)
                        {
                        }
                    }
                }
            }
        };
        
        dispatchThread.start();
    }
    
    
    /**
     * Dispatch event generated by the specified source
     * @param src object that is the source of the event
     * @param e event object
     */
    public void publishEvent(Event e)
    {
        try
        {
            eventQueue.put(e);
        }
        catch (InterruptedException e1)
        {
        }
    }
    
    
    /**
     * Registers a listener for a particular source object
     * @param src
     * @param listener
     */
    public synchronized void register(Object src, IEventListener listener)
    {
        List<IEventListener> objListeners = listeners.get(src);
        if (objListeners == null)
            objListeners = new ArrayList<IEventListener>();
        
        objListeners.add(listener);
    }
    
    
    public synchronized void start()
    {
        this.started = true;
        this.paused = false;
        this.notify();
    }
    
    
    public synchronized void stop()
    {
        this.started = false;
        this.paused = false;
        this.notify();
    }
    
    
    public synchronized void pause()
    {
        this.paused = true;
    }
}
